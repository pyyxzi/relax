<!DOCTYPE html>
<html>

<head lang="en">
    <meta charset="UTF-8">
    <title>黑洞模拟</title>
    <link rel="icon" href="ico/momo.ico" type="image/x-icon">
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            -webkit-user-select: none;
            background-color: #000;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }

        .tips {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #FFF;
            z-index: 10;
            font-size: 14px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            opacity: 0.7;
        }

        .tips:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        #cas {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            margin: auto;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        .title {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            text-align: center;
            color: #fff;
            font-size: 28px;
            text-shadow: 0 0 10px #00a2ff, 0 0 20px #00a2ff;
            opacity: 0.8;
        }
    </style>
</head>

<body oncontextmenu='return false'>
    <div class="stars"></div>
    <h1 class="title">黑洞模拟器</h1>
    <span class="tips">左键创建黑洞，右键删除黑洞</span>
    <canvas id="cas"></canvas>

    <script src="./js/stats.min.js"></script>
    <!-- <script src="test.js"></script> -->
    <script>
        // 创建星空背景
        function createStars() {
            const stars = document.querySelector('.stars');
            const count = 200;

            for (let i = 0; i < count; i++) {
                let star = document.createElement('div');
                let size = Math.random() * 2;

                star.style.position = 'absolute';
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.backgroundColor = '#fff';
                star.style.borderRadius = '50%';
                star.style.opacity = Math.random();
                star.style.animation = `twinkle ${2 + Math.random() * 3}s infinite ease-in-out`;

                stars.appendChild(star);
            }
        }

        // 添加星星闪烁动画
        const style = document.createElement('style');
        style.innerHTML = `
            @keyframes twinkle {
                0%, 100% { opacity: 0.3; }
                50% { opacity: 1; }
            }
        `;
        document.head.appendChild(style);

        // 创建星空
        createStars();
    </script>

    <script>
        // Generated by CoffeeScript 1.9.3
        (function () {
            var BH_SIZE, BlackHole, Particle, RAF, animate, bhImage, blackholes, bufferCanvas, bufferCtx, canvas, ctx, execAnimate, particles, stats, target;

            particles = [];

            blackholes = [];

            BH_SIZE = 20; // 增大默认黑洞尺寸

            stats = new Stats();

            stats.setMode(0);

            stats.domElement.style.position = 'absolute';

            stats.domElement.style.right = '0px';

            stats.domElement.style.top = '0px';

            document.body.appendChild(stats.domElement);

            canvas = document.getElementById('cas');

            ctx = canvas.getContext("2d");

            bufferCanvas = document.createElement("canvas");

            bufferCtx = bufferCanvas.getContext("2d");

            bufferCanvas.width = canvas.width = document.body.offsetWidth;

            bufferCanvas.height = canvas.height = document.body.offsetHeight;

            window.onresize = function () {
                bufferCanvas.width = canvas.width = document.body.offsetWidth;
                return bufferCanvas.height = canvas.height = document.body.offsetHeight;
            };

            RAF = (function () {
                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
            })();

            Particle = (function () {
                function Particle(options) {
                    this.x = options.x, this.y = options.y, this.r = options.r, this.color = options.color;
                    this._init();
                }

                Particle.prototype._init = function () {
                    this.vx = Math.random() * 4 - 2;
                    this.vy = Math.random() * 4 - 2;
                    this.ax = 0;
                    this.ay = 0;
                    // 添加粒子初始生命值
                    this.life = Math.random() * 100 + 50;
                    this.maxLife = this.life;
                    return this;
                };

                Particle.prototype.move = function () {
                    var maxSpeed, ref, ref1;

                    // 减少生命值
                    this.life -= 0.1;

                    // 根据生命值动态调整透明度
                    this.opacity = this.life / this.maxLife;

                    this.vx += this.ax;
                    this.vy += this.ay;
                    maxSpeed = 12; // 提高最大速度
                    this.vx = Math.abs(this.vx) > maxSpeed ? maxSpeed * Math.abs(this.vx) / this.vx : this.vx;
                    this.vy = Math.abs(this.vy) > maxSpeed ? maxSpeed * Math.abs(this.vy) / this.vy : this.vy;
                    this.oldx = this.x;
                    this.oldy = this.y;
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vx = (0 <= (ref = this.x) && ref <= canvas.width + this.r * 2) ? this.vx : -this.vx * 0.98;
                    return this.vy = (0 <= (ref1 = this.y) && ref1 <= canvas.height + this.r * 2) ? this.vy : -this.vy * 0.98;
                };

                Particle.prototype.attract = function () {
                    var angle, bh, cx, cy, k, lax, lay, len, power, dist, results;
                    this.ax = this.ay = 0;
                    results = [];
                    for (k = 0, len = blackholes.length; k < len; k++) {
                        bh = blackholes[k];
                        cx = bh.x - this.x;
                        cy = bh.y - this.y;
                        dist = Math.sqrt(cx * cx + cy * cy);

                        // 当粒子靠近黑洞时，快速减少生命值
                        if (dist < bh.r * 3) {
                            this.life -= (bh.r * 3 - dist) / (bh.r * 3) * 2;
                        }

                        angle = Math.atan2(cx, cy);
                        power = bh.power * 0.15; // 增强黑洞吸引力
                        lax = Math.abs(power * Math.sin(angle));
                        lay = Math.abs(power * Math.cos(angle));
                        this.ax += cx > 0 ? lax : -lax;
                        results.push(this.ay += cy > 0 ? lay : -lay);
                    }
                    return results;
                };

                Particle.prototype.draw = function () {
                    bufferCtx.save();

                    // 根据生命值调整颜色
                    var colorValue = Math.floor(this.life / this.maxLife * 255);
                    var r = 255;
                    var g = colorValue;
                    var b = Math.min(255, colorValue + 50);
                    var alpha = Math.min(1, this.opacity * 1.5);

                    bufferCtx.strokeStyle = "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
                    bufferCtx.lineCap = bufferCtx.lineJoin = "round";
                    bufferCtx.lineWidth = this.r;
                    bufferCtx.beginPath();
                    bufferCtx.moveTo(this.oldx - this.r, this.oldy - this.r);
                    bufferCtx.lineTo(this.x - this.r, this.y - this.r);
                    bufferCtx.stroke();
                    bufferCtx.restore();

                    // 如果粒子生命值用完，重置它
                    if (this.life <= 0) {
                        this.x = canvas.width * Math.random();
                        this.y = canvas.height * Math.random();
                        this._init();
                    }
                    return this;
                };

                return Particle;

            })();

            BlackHole = (function () {
                function BlackHole(options) {
                    this.x = options.x, this.y = options.y, this.r = options.r, this.power = options.power;
                    this.step = 2;
                    this.bigger = 8; // 增大脉动效果
                    this.pulseSpeed = Math.random() * 0.5 + 0.5; // 随机脉动速度

                    // 为黑洞选择更鲜艳的颜色
                    var colorSchemes = [
                        { hue: 0 },     // 红色
                        { hue: 60 },    // 黄色
                        { hue: 120 },   // 绿色
                        { hue: 180 },   // 青色
                        { hue: 240 },   // 蓝色
                        { hue: 280 },   // 紫色
                        { hue: 320 }    // 粉色
                    ];

                    var scheme = colorSchemes[Math.floor(Math.random() * colorSchemes.length)];
                    this.hue = scheme.hue;

                    this.animate(0);
                }

                BlackHole.prototype.drawLight = function (ctx) {
                    var imgr;
                    if (this.isAdd) {
                        if ((this.ir += this.step * this.pulseSpeed) > (this.r + this.bigger)) {
                            this.isAdd = false;
                        }
                    } else {
                        this.ir = this.ir <= this.r ? this.r : this.ir - this.step * this.pulseSpeed;
                        if (this.destory && this.ir === this.r) {
                            blackholes.splice(blackholes.indexOf(this), 1);
                        }
                    }

                    // 绘制发光特效 - 增强亮度和饱和度
                    imgr = this.ir * 1.8; // 增大光晕范围
                    ctx.save();

                    // 第一层光环 - 使用更高的亮度值
                    var grd = ctx.createRadialGradient(this.x, this.y, this.ir * 0.5, this.x, this.y, imgr);
                    grd.addColorStop(0, "hsla(" + this.hue + ", 100%, 60%, 0.9)");  // 增加亮度和不透明度
                    grd.addColorStop(0.5, "hsla(" + this.hue + ", 100%, 40%, 0.6)"); // 增加中间颜色的不透明度
                    grd.addColorStop(1, "hsla(" + this.hue + ", 100%, 20%, 0)");

                    ctx.beginPath();
                    ctx.fillStyle = grd;
                    ctx.arc(this.x, this.y, imgr, 0, Math.PI * 2);
                    ctx.fill();

                    // 添加更明显的光晕效果
                    ctx.beginPath();
                    ctx.strokeStyle = "hsla(" + this.hue + ", 100%, 80%, 0.6)"; // 使用高亮度和更高不透明度
                    ctx.lineWidth = 3; // 增加线宽
                    ctx.arc(this.x, this.y, imgr * 0.8, 0, Math.PI * 2);
                    ctx.stroke();

                    // 第二层光晕
                    ctx.beginPath();
                    ctx.strokeStyle = "hsla(" + this.hue + ", 100%, 90%, 0.4)"; // 使用更高亮度
                    ctx.lineWidth = 2;
                    ctx.arc(this.x, this.y, imgr * 1.1, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                };

                BlackHole.prototype.draw = function (ctx) {
                    var that = this;
                    ctx.save();

                    // 黑洞中心
                    ctx.beginPath();
                    ctx.fillStyle = "#000";
                    ctx.arc(that.x, that.y, that.ir, 0, Math.PI * 2);
                    ctx.fill();

                    // 黑洞边缘 - 增强边缘颜色
                    var grd = ctx.createRadialGradient(that.x, that.y, that.ir * 0.7, that.x, that.y, that.ir * 1.1);
                    grd.addColorStop(0, "#000");
                    grd.addColorStop(0.7, "hsla(" + this.hue + ", 100%, 15%, 0.9)"); // 添加中间颜色
                    grd.addColorStop(1, "hsla(" + this.hue + ", 100%, 50%, 0.8)"); // 增加边缘亮度

                    ctx.beginPath();
                    ctx.fillStyle = grd;
                    ctx.arc(that.x, that.y, that.ir * 1.1, 0, Math.PI * 2);
                    ctx.fill();

                    // 添加明亮的边缘线
                    ctx.beginPath();
                    ctx.strokeStyle = "hsla(" + this.hue + ", 100%, 70%, 0.9)";
                    ctx.lineWidth = 2;
                    ctx.arc(that.x, that.y, that.ir * 1.05, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.restore();
                    return this;
                };

                BlackHole.prototype.animate = function (ir) {
                    this.ir = ir;
                    return this.isAdd = true;
                };

                BlackHole.prototype.attract = function (bh) {
                    var cx, cy, jl, lax, lay, power;
                    if (bh.r >= this.r) {
                        cx = bh.x - this.x;
                        cy = bh.y - this.y;
                        jl = Math.sqrt(cx * cx + cy * cy);
                        power = (bh.r - this.r) * 10 / jl + 0.5;
                        lax = Math.abs(power * cx / jl);
                        lay = Math.abs(power * cy / jl);
                        this.x += cx > 0 ? lax : -lax;
                        return this.y += cy > 0 ? lay : -lay;
                    }
                };

                BlackHole.prototype.check = function (bh) {
                    var cr, cx, cy, lbh, nbh, ref, ref1;
                    if (!bh || !(bh instanceof BlackHole) || this.destory || bh.destory) {
                        return false;
                    }
                    cx = bh.x - this.x;
                    cy = bh.y - this.y;
                    cr = bh.ir + this.ir;
                    cx = Math.abs(cx);
                    cy = Math.abs(cy);
                    if (cx < cr && cy < cr && Math.sqrt(cx * cx + cy * cy) <= Math.abs(bh.r - this.r) + 3) {
                        if (bh.r > this.r) {
                            ref = [bh, this], nbh = ref[0], lbh = ref[1];
                        } else {
                            ref1 = [this, bh], nbh = ref1[0], lbh = ref1[1];
                        }
                        nbh.r = ~~Math.sqrt(bh.r * bh.r + this.r * this.r);
                        nbh.power = bh.power + this.power;

                        // 合并时的特效
                        createMergeEffect(nbh.x, nbh.y, Math.max(bh.r, this.r));

                        nbh.animate(Math.max(bh.r, this.r));
                        if (nbh.r > 50) {
                            nbh.destory = true;
                        }
                        return lbh;
                    }
                    return false;
                };

                return BlackHole;

            })();

            // 添加黑洞合并特效
            function createMergeEffect(x, y, radius) {
                for (var i = 0; i < 20; i++) {
                    var angle = Math.random() * Math.PI * 2;
                    var distance = radius * 2;
                    var px = x + Math.cos(angle) * distance;
                    var py = y + Math.sin(angle) * distance;
                    particles.push(new Particle({
                        x: px,
                        y: py,
                        r: Math.random() * 3 + 2,
                        color: "rgba(255,255,255,.8)"
                    }));
                }
            }

            bhImage = (function () {
                var bhCas, bhCtx, i, k, opacity;
                bhCas = document.createElement("canvas");
                bhCas.width = bhCas.height = 50;
                bhCtx = bhCas.getContext("2d");
                opacity = 0;
                for (i = k = 0; k < 20; i = ++k) {
                    opacity += 0.05;
                    bhCtx.beginPath();
                    bhCtx.fillStyle = "rgba(188,186,187," + opacity + ")";
                    bhCtx.arc(bhCas.width / 2, bhCas.height / 2, 25 - i, 0, Math.PI * 2);
                    bhCtx.fill();
                }
                return bhCas;
            })();

            target = null;

            canvas.onmousedown = function (e) {
                var bh, cx, cy, i, k, len, x, y;
                x = e.clientX - this.offsetLeft;
                y = e.clientY - this.offsetTop;
                for (i = k = 0, len = blackholes.length; k < len; i = ++k) {
                    bh = blackholes[i];
                    cx = bh.x - x;
                    cy = bh.y - y;
                    if (cx * cx + cy * cy <= bh.r * bh.r) {
                        target = bh;
                        break;
                    }
                }
                if (!target && e.button === 0) {
                    // 创建黑洞时的特效
                    createMergeEffect(x, y, BH_SIZE);

                    return blackholes.push(new BlackHole({
                        x: x,
                        y: y,
                        r: BH_SIZE,
                        power: 3
                    }));
                } else if (e.button === 2 && bh) {
                    bh.destory = true;
                    bh.animate(bh.r);
                    return bh.r += 5;
                }
            };

            canvas.onmousemove = function (e) {
                var x, y;
                if (target) {
                    x = e.clientX - this.offsetLeft;
                    y = e.clientY - this.offsetTop;
                    target.x = x;
                    return target.y = y;
                }
            };

            canvas.onmouseup = canvas.onmouseout = function (e) {
                return target = null;
            };

            execAnimate = function () {
                var i, k;
                for (i = k = 1; k < 1500; i = ++k) {  // 增加粒子数量
                    particles.push(new Particle({
                        x: canvas.width * Math.random(),
                        y: canvas.height * Math.random(),
                        r: Math.random() * 2 + 1,
                        color: "rgba(255,255,255,.5)"
                    }));
                }
                return animate();
            };

            animate = function () {
                var bh, bh2, deleArray, delebh, i, j, k, l, len, len1, len2, len3, len4, m, n, o, p;
                bufferCtx.save();
                bufferCtx.globalCompositeOperation = 'destination-out';
                bufferCtx.globalAlpha = 0.3;
                bufferCtx.fillRect(0, 0, canvas.width, canvas.height);
                bufferCtx.restore();
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 添加画面后处理特效
                ctx.save();
                ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();

                for (i = k = 0, len = blackholes.length; k < len; i = ++k) {
                    bh = blackholes[i];
                    if (bh) {
                        bh.drawLight(ctx);
                    }
                }
                deleArray = [];
                for (i = l = 0, len1 = blackholes.length; l < len1; i = ++l) {
                    bh = blackholes[i];
                    if (bh) {
                        bh.draw(ctx);
                    }
                    for (j = m = 0, len2 = blackholes.length; m < len2; j = ++m) {
                        bh2 = blackholes[j];
                        if (!bh || !bh2 || bh === bh2) {
                            continue;
                        }
                        bh.attract(bh2);
                        if (j > i && (delebh = bh.check(bh2))) {
                            deleArray.push(delebh);
                        }
                    }
                }
                for (n = 0, len3 = deleArray.length; n < len3; n++) {
                    delebh = deleArray[n];
                    blackholes.splice(blackholes.indexOf(delebh), 1);
                }
                for (o = 0, len4 = particles.length; o < len4; o++) {
                    p = particles[o];
                    p.attract();
                    p.move();
                    p.draw();
                }
                ctx.drawImage(bufferCanvas, 0, 0);

                // 添加屏幕闪烁效果
                if (blackholes.length > 0 && Math.random() < 0.02) {
                    ctx.save();
                    ctx.fillStyle = "rgba(255, 255, 255, 0.03)";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.restore();
                }

                stats.update();
                return RAF(animate);
            };

            execAnimate();

        }).call(this);

        //# sourceMappingURL=test.js.map

    </script>



</body>

</html>